<span style="@ImageSpanStyle">
    <img id="mapgeo-img" src="@ImageSrc" alt="@ImageAlt" style="@ImageStyle" @onmouseover="OnPointerEnter" @onpointerenter="OnPointerEnter" @ontouchenter="OnPointerEnter" @onmouseout="OnPointerLeave" @onpointerleave="OnPointerLeave" @ontouchleave="OnPointerLeave" @onclick="OnClick" @ontouchstart="OnClick" @ontouchend="OnClickOut"/>
</span>


@code {
    [Parameter]
    public PictureItemStructure PictureItem{ get; set; }

    [Parameter]
    public MapViewMode ViewMode{ get; set; }

    [Parameter]
    public LevelLocation ThisLocation{ get; set; }

    [Parameter]
    public EventCallback<LevelLocation> OnPointerMapItemChanged { get; set; }

    [Parameter]
    public EventCallback<LevelLocation> OnClickMapItem { get; set; }

    [Parameter]
    public bool ForceShadow{ get; set; }

    [Parameter]
    public int PepoleAmount { get; set; } = 0;

    public string ImageAlt
    {
        get
        {
            return System.IO.Path.GetFileNameWithoutExtension(PictureItem.Name);
        }
    }

    public string ImageSrc
    {
        get
        {
            return PictureItem.Path;
        }
    }

    public string ImageSpanStyle
    {
        get{
            Bitmap bitmap = (Bitmap)Bitmap.FromFile(System.IO.Path.Combine("wwwroot", PictureItem.Path));

#warning 不清楚中心点是否与scale有关
            return String.Format(
                "left:{0}px; " +
                "top:{1}px; " +
                "transform-origin: {2}% {3}%; " +
                "z-index: {4}; " +
                "position: absolute;",
                PictureItem.Position.Item1,
                PictureItem.Position.Item2,
                PictureItem.TransformOrigin.Item1 / bitmap.Width * 100.0,
                PictureItem.TransformOrigin.Item2 / bitmap.Height * 100.0,
                (useShadowClass ? int.MaxValue : PictureItem.ZIndex)
            );
        }
    }

    public string ImageStyle
    {
        get
        {
            Bitmap bitmap = (Bitmap)Bitmap.FromFile(System.IO.Path.Combine("wwwroot", PictureItem.Path));

#warning 不清楚中心点是否与scale有关
            StringBuilder styleText = new StringBuilder();
            styleText.Append(String.Format(
                "transform-origin: {0}% {1}%; " +
                //"transform: scale({2}, {3}); " +
                "width: {2}px; " + //注意：这里貌似用百分比不行
                "height: {3}px; " + //注意：这里貌似用百分比不行
                "transform: rotate({4}deg); " +
                "opacity: {5}; " +
                "position: absolute;",
                PictureItem.TransformOrigin.Item1 / bitmap.Width * 100.0,
                PictureItem.TransformOrigin.Item2 / bitmap.Height * 100.0,
                //PictureItem.Scale.Item1,
                //PictureItem.Scale.Item2,
                PictureItem.Scale.Item1 * bitmap.Width/* * (useShadowClass || ForceShadow ? 1.2 : 1.0)*/,
                PictureItem.Scale.Item2 * bitmap.Height/* * (useShadowClass || ForceShadow ? 1.2 : 1.0)*/,
                PictureItem.RotateAngle,
                PictureItem.Opacity
            ));
            #warning String.Format会忽略掉第7个及以后的参数？？？
            styleText.Append(String.Format(
                "-webkit-filter: grayscale({0}%); filter: grayscale({0}%); ",
                PepoleAmount == 0 ? "100" : "0"
            ));

            if (useShadowClass || ForceShadow)
            {
                styleText.Append(" -webkit-filter: drop-shadow(8px 8px 10px yellow); filter: drop-shadow(0px 0px 10px yellow);");
            }

            return styleText.ToString();
        }
    }

    private bool useShadowClass = false;
    public void OnPointerEnter()
    {
        //OnPointerMapItemChanged.InvokeAsync(ThisLocation).Wait();

        if (!useShadowClass)
        {
            useShadowClass = true;
            StateHasChanged();
        }
    }
    public void OnPointerLeave()
    {
        //#warning 不知道会不会出现极端情况。
        //OnPointerMapItemChanged.InvokeAsync(null).Wait();

        if (useShadowClass)
        {
            useShadowClass=false;
            StateHasChanged();
        }
    }

    public void OnClick()
    {
        OnClickMapItem.InvokeAsync(ThisLocation).Wait();
    }

    public void OnClickOut()
    {
        OnClickMapItem.InvokeAsync(null).Wait();
    }
}